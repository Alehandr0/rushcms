<?php

	// Файл-роутер RushCMS. Развернутый справочный комментарий — внизу страницы
	// Документация по RushCMS: https://rush-cms.com/

	$RootPath = $_SERVER["DOCUMENT_ROOT"];
	
	include_once $RootPath.'/options.php'; // Здесь хранятся основные настройки RushCMS: подключения к БД и т.д.
	include_once $RootPath.'/rc/php/main_func.php'; // Здесь хранятся основные предопределенные функции RushCMS
	
	$Auth = Auth(); // Получаем права пользователя. Это число >= 0. Подробнее — см. в описании к ф-и Auth в main_func.php

	$AddData = array(
	
		'Auth' => $Auth,
	
	);

	$UniqData = array(
	
		'PagePath' => '/'.$_REQUEST['pp'],

	);

	//	Дополнительная обработка адреса запрашиваемой страницы и параметров уникальности:

	//	<<...Место для вашего кода...>>
	
/*
========== Справка ==============================================================
	
HHHH	Если вы впервые сталкиваетесь с RushCMS, то прочитайте инструкцию по
HHHH	адресу https://rush-cms.com/ Час вашего времени и вы будете пользоваться
HHHH	RushCMS с полным пониманием того, что делаете.
		
	
		$AddData — массив значений, который будет добавлен к данным страницы из
		БД (т.е. к $PageDataSQL, которым можно пользоваться в функциях обработки
		шаблона из /rc/tmpl/tmpl_func.php).
		
		При добавлении значений к ключу прибавляется префикс "ad_". Т.е,
		[Auth] => 2 из $AddData станет [ad_Auth] => 2 в $PageDataSQL
		
		=========================================================================
	
		$UniqData — массив, который определяет параметры, по которым можно
		однозначно установить уникальность страницы. В простейшем случае это
		адрес страницы БЕЗ УЧЕТА ПЕРЕДАВАЕМЫХ ПАРАМЕТРОВ. Массив $UniqData 
		используется для работы с системой кэширования RushCMS.
		
		Данные из $UniqData добавляются в $PageDataSQL по аналогии с $AddData.
		Добавляемый префикс — "ud_".  Т.е, [PagePath] => /ab/ из $UniqData станет
		[ud_PagePath] => /ab/ в $PageDataSQL
		
		Простой пример. Допустим, на сайте есть страница /mess/?m=1	которая 
		выводит пользователю сообщение «Привет». И страница /mess/?m=2 которая
		выводит сообщение «Пока!». Получается, что выводимое ими содержимое
		зависит не только от адреса страницы без параметров (он у обеих страниц
		одинаковый: '/mess/'), но и от параметра 'm'. Т.е. этот параметр
		определяет уникальность страницы. Если мы забудем указать его в 
		$UniqData, то обеим страницам будет соответсвовать один и тот же файл
		кэша. Т.е. по обоим адресам будет выводиться одинаковое сообщение: либо
		«Привет», либо «Пока!». В зависимотси от того, какая страница будет
		закэширована первой. Чтобы этого не происходило, нам необходимо
		обозначить значимость этого праметра. Вот так:
		
			$UniqData = array(
			
				'PagePath' => '/'.$_REQUEST['pp'],
				'MessageNum' => intval($_REQUEST['m']),

			);
		
		Теперь каждой странице сайта из нашего примера соответствует свой файл
		кэша и они будут отображаться правильно. Но тут есть несколько
		подводных камней. О чем читайте ниже.
		
		=========================================================================
		
		После определения массива $UniqData вы можете вставить свой код. Это
		место, где вы можете, в зависимости от некоторых условий, изменить 
		входящий адрес (перезаписав значение $UniqData['PagePath']), осуществить 
		редирект или выдать страницу 404.
		
		Для выдачи 404 страницы используйте следующий код:
		
			Show404Page();
			exit;
			
		Для 301 редиректа код такой:
		
			header("HTTP/1.1 301 Moved Permanently");
			header("Location: /some/path/");
			exit;
		
		Если вы, например, хотите (не знаю зачем) выдать по URL /some/ содержимое
		страницы с URL /else/ (т.е. ее дубликат), то сделайте так:
		
			$UniqData['PagePath'] = '/else/';
		
		Разумеется, все это должно происходить в зависимости от каких-то условий.
		Логические конструкции в примерах выше были опущены.
		
!!!>	ВАЖНО! В примере выше (с добавлением параметра 'm' в массив $UniqData)
		есть проблема, которую необходимо понимать и учитывать.

		Кэш страницы в RushCMS записыывается в отдельный файл. Который помещается
		в каталог /rc/_cache/ Имя этого файла получается так:
		
		[тип_кэша]_[хэш_массива_$UniqData].cache
		
		[тип_кэша] — это число 1 или 2. '1' обозначает, что это полный кэш
		страницы, который не нуждается в дополнительной обработке. Такой кэш сразу
		будет выведен. '2' обозначает, что в файле кэша есть места для обработки.
		Такой кэш будет обработан и только затем отдан. Подробнее о кэше RushCMS
		читайте в инструкции на https://rush-cms.com/
		
		Таким образом для страницы /mess/?m=1 будет сформирован один файл кэша,
		для страницы /mess/?m=2 — другой, а для страницы /mess/?m=3 — третий...
		Стоп. Вот и проблема. Ведь в нашем примере нет страницы для /mess/?m=3
		
		И дело даже не в том, что она выведет непонятно что: это зависит от того,
		как вы обрабатываете получаемый параметр 'm' в своем шаблоне. Дело в том,
		что какой-нибудь нехороший дядя (или тетя) могут начать закидывать ваш
		сервер запросами страниц: /mess/?m=10, /mess/?m=11 ... /mess/?m=55 и т.д.
		Это приведет к тому, что при каждом запросе у вас будет полностью
		генерироваться страница и создаваться новый, не нужный остальным
		нормальным пользователям вашего сайта файл кэша. Более того, если оставить
		код нашего примера с $UniqData в его исходном виде, то вызов ЛЮБОЙ
		страницы с параметром 'm' вызовет появление нового файла кэша. Например,
		вызовы страниц /some/?m=1 и /some/?m=2 приведут к созданию еще двух файлов
		кэша. В настройках RushCMS (файл /options.php) есть переменная 
		$MaxCacheFiles, которая определяет  максимальное количество файлов кэша,
		которое может храниться на вашем сервере. Так что переполнения не 
		произойдет. Однако нагрузка за счет того, что страницы будут каждый раз
		генерироваться полностью, возрастет. Это можно использовать в целях 
		увеличения эффективности совершения	DDoS-атаки.
		
		Чтобы всего этого не произошло необходимо проверять получаемые «из вне»
		данные на соответствие ожиданиям. Для нашего примера стоит сделать так:
		
			$UniqData = array(
			
				'PagePath' => '/'.$_REQUEST['pp'],
				'MessageNum' => intval($_REQUEST['m']),

			);

			if($UniqData['PagePath']!='/mess/' || $UniqData['MessageNum']>2){
			
				$UniqData['MessageNum'] = 1;
				
			}
			
		Таким образом для всех страниц, где параметр 'm' не является определяющим
		уникальность и для случаев, когда он превышает допустимые пределы, его
		значение устанавливается как '1'.
		
		Это хорошее решение до тех пор, пока на сайте не появится третье
		сообщение, которое должно выводиться по запросу /mess/?m=3 Если
		увеличение количества сообщений не планируется или вы уверены, что не
		забудете изменить логику — смело пользуйтесь этим решением. Также можно
		просто задать несколько более широкие рамки проверки в расчете на будущее:
		
			if($UniqData['PagePath']!='/mess/' || $UniqData['MessageNum']>10){
			
				$UniqData['MessageNum'] = 1;
				
			}

		Это частично решит проблему и, в то же время, не даст плохишам особой
		свободы действий.
		
		Есть и самый простой выход — просто сделайте вывод сообщений
		некэшируемым. Только при принятии окончательного решения о выборе
		способа реализации помните, что некэшируемые части «едят» больше
		ресурсов. Например, если ваши сообщения выводятся с помощью десятка
		запросов к БД (никогда не доводите до такого!), то эти запросы будут
		осуществляться при каждом запросе страницы, что может вызвать довольно
		существенное увеличение нагрузки.
		
		RushCMS — это немного о творчестве!

=================================================================================		
*/

?>